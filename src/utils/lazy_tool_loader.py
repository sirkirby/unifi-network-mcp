"""Lazy tool loader for on-demand tool registration.

This module implements true lazy loading of tools, registering them only
when first called by an LLM. This dramatically reduces initial context usage.
"""

import importlib
import json
import logging
import re
from functools import wraps
from pathlib import Path
from typing import Any, Callable, Dict, Set

logger = logging.getLogger("unifi-network-mcp")


def _load_module_map_from_manifest() -> Dict[str, str]:
    """Load tool-to-module mapping from the manifest file.

    The manifest is auto-generated by scripts/generate_tool_manifest.py and
    includes a module_map that stays in sync with the actual tools.

    Returns:
        Dictionary mapping tool names to their module paths, or empty dict if unavailable
    """
    # Try relative to this file first
    manifest_path = Path(__file__).parent.parent / "tools_manifest.json"

    if not manifest_path.exists():
        # Try relative to cwd
        manifest_path = Path("src/tools_manifest.json")

    if not manifest_path.exists():
        logger.warning("Tools manifest not found for fallback loading")
        return {}

    try:
        with open(manifest_path) as f:
            manifest = json.load(f)
        module_map = manifest.get("module_map", {})
        logger.info(f"Loaded module map from manifest with {len(module_map)} tools")
        return module_map
    except Exception as e:
        logger.warning(f"Failed to load module map from manifest: {e}")
        return {}


def _build_tool_module_map() -> Dict[str, str]:
    """Build tool-to-module mapping by scanning tool files.

    This dynamically discovers all tools and their modules, eliminating the need
    for a manually-maintained static mapping that can get out of sync.

    Falls back to loading from tools_manifest.json if the tools directory
    is not found (e.g., in unusual deployment scenarios).
    """
    tool_map: Dict[str, str] = {}

    # Find the tools directory
    # Try relative to this file first, then fall back to cwd
    this_dir = Path(__file__).parent
    tools_dir = this_dir.parent / "tools"

    if not tools_dir.exists():
        tools_dir = Path("src/tools")

    if not tools_dir.exists():
        logger.warning("Tools directory not found, falling back to manifest")
        return _load_module_map_from_manifest()

    # Scan each .py file in tools directory
    for tool_file in tools_dir.glob("*.py"):
        if tool_file.name.startswith("_"):
            continue

        module_name = f"src.tools.{tool_file.stem}"

        try:
            # Read file and look for @server.tool or @permissioned_tool decorators
            content = tool_file.read_text()

            # Find tool names using simple pattern matching
            # Looking for: name="unifi_xxx" or name='unifi_xxx'
            # Note: pattern uses literal 'unifi_' prefix, not a character class
            pattern = r'name\s*=\s*["\'](unifi_[a-z_]+)["\']'
            matches = re.findall(pattern, content)

            for tool_name in matches:
                if tool_name.startswith("unifi_"):
                    tool_map[tool_name] = module_name

        except Exception as e:
            logger.debug(f"Error scanning {tool_file}: {e}")

    logger.debug(f"Built dynamic tool map with {len(tool_map)} tools")
    return tool_map


# Build the tool map dynamically at module load time
# Falls back to manifest if dynamic discovery fails
TOOL_MODULE_MAP: Dict[str, str] = _build_tool_module_map()


class LazyToolLoader:
    """Manages lazy/on-demand tool loading."""

    def __init__(self, server, tool_decorator: Callable):
        """Initialize the lazy tool loader.

        Args:
            server: FastMCP server instance
            tool_decorator: The decorator function to register tools
        """
        self.server = server
        self.tool_decorator = tool_decorator
        self.loaded_modules: Set[str] = set()
        self.loaded_tools: Set[str] = set()
        self._loading = False

        logger.info("Lazy tool loader initialized")

    def is_loaded(self, tool_name: str) -> bool:
        """Check if a tool is already loaded."""
        return tool_name in self.loaded_tools

    async def load_tool(self, tool_name: str) -> bool:
        """Load a tool on-demand.

        Args:
            tool_name: Name of the tool to load

        Returns:
            True if tool was loaded successfully, False otherwise
        """
        # Avoid recursive loading
        if self._loading:
            return False

        if self.is_loaded(tool_name):
            logger.debug(f"Tool '{tool_name}' already loaded")
            return True

        module_path = TOOL_MODULE_MAP.get(tool_name)
        if not module_path:
            logger.warning(f"No module mapping found for tool '{tool_name}'")
            return False

        try:
            self._loading = True
            logger.info(f"ðŸ”„ Lazy-loading tool '{tool_name}' from '{module_path}'")

            # Import the module (this will trigger @server.tool decorators)
            if module_path not in self.loaded_modules:
                importlib.import_module(module_path)
                self.loaded_modules.add(module_path)

            # Mark tool as loaded
            self.loaded_tools.add(tool_name)

            logger.info(f"âœ… Tool '{tool_name}' loaded successfully")
            return True

        except Exception as e:
            logger.error(f"Failed to load tool '{tool_name}': {e}", exc_info=True)
            return False
        finally:
            self._loading = False

    async def intercept_call_tool(self, original_call_tool: Callable, name: str, arguments: dict) -> Any:
        """Intercept tool calls to load tools on-demand.

        Args:
            original_call_tool: Original call_tool method
            name: Tool name
            arguments: Tool arguments

        Returns:
            Result from the tool execution
        """
        # Try to load the tool if not already loaded
        if not self.is_loaded(name) and name in TOOL_MODULE_MAP:
            loaded = await self.load_tool(name)
            if not loaded:
                raise ValueError(f"Failed to load tool '{name}'")

        # Call the original method
        return await original_call_tool(name, arguments)


def setup_lazy_loading(server, tool_decorator: Callable) -> LazyToolLoader:
    """Setup lazy tool loading by intercepting call_tool.

    Args:
        server: FastMCP server instance
        tool_decorator: The decorator function to register tools

    Returns:
        LazyToolLoader instance
    """
    loader = LazyToolLoader(server, tool_decorator)

    # Intercept call_tool to load tools on-demand
    original_call_tool = server.call_tool

    @wraps(original_call_tool)
    async def lazy_call_tool(name: str, arguments: dict):
        return await loader.intercept_call_tool(original_call_tool, name, arguments)

    server.call_tool = lazy_call_tool

    logger.info("âœ¨ Lazy tool loading enabled - tools will be loaded on first use")

    return loader
